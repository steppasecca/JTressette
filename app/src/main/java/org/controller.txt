package org.controller;

import org.model.*;
import org.events.*;
import org.view.GamePanel;
import org.view.TablePanel;

import javax.swing.*;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Collections;

/**
 * GameController: connette il TressetteGame (model) con la GamePanel (view).
 */
public class GameController implements Observer {

    private final TressetteGame game;
    private final GamePanel view;
    private final Navigator navigator;
    private final Player humanPlayer; // il player controllato dall'utente (assunto uno solo)

    public GameController(TressetteGame game, GamePanel view, Navigator navigator, Player humanPlayer) {
        this.game = game;
        this.view = view;
        this.navigator = navigator;
        this.humanPlayer = humanPlayer;

        // crea e imposta il TablePanel nella view (tavolo parametrico 2/4)
        TablePanel tp = new TablePanel(game.getPlayers());
        this.view.setTablePanel(tp);

        // Register as observer 
        this.game.addObserver(this);

        // Set view callback
        this.view.setCardClickListener(card -> handleHumanPlay(card));

        // inizializza view con stato corrente
        refreshView();

        // se l'IA inizia per prima, attivala
        triggerNextAiIfNeeded();
    }

    // Observer callback dal modello
    @Override
    public void update(Observable o, Object arg) {
        SwingUtilities.invokeLater(() -> {
            // se riceviamo ModelEventMessage, gestiscilo; altrimenti refresh generale
            if (arg instanceof ModelEventMessage) {
                ModelEventMessage msg = (ModelEventMessage) arg;
                switch (msg.getEvent()) {
                    case CARDS_DEALT:
                        // nuove mani: rinfresca completamente
                        refreshView();
                        break;
					case CARD_PLAYED:
						refreshView();
                    case TURN_STARTED:
                        Integer idx = (Integer) msg.getPayload();
                        if (idx != null) view.setCurrentPlayer(idx);
                        break;
                    case TRICK_ENDED:
                        TrickResult tr = (TrickResult) msg.getPayload();
                        if (tr != null) {
                            // mostra la carta vincente e rinfresca (punteggi, mani ecc.)
                            view.showPlayedCard(tr.getWinnerIndex(), tr.getWinningCard());
                        }
                        refreshView();
                        break;
                    case PROFILE_CHANGED:
                        // payload è UserProfile; se vuoi aggiornare header/menu gestiscilo qui
                        break;
                    case GAME_OVER:
                        handleGameOver();
                        break;
                    default:
                        // altri eventi: refresh per sicurezza
                        refreshView();
                        break;
                }
            } else {
                // backward compatibility (non dovresti arrivare qui dopo il refactor)
                refreshView();
            }

            // dopo ogni aggiornamento prova ad avviare IA se serve
            triggerNextAiIfNeeded();
        });
    }

    /** 
	 * Aggiorna la view leggendo lo stato dal model 
	 */
    private void refreshView() {
        // aggiorna mano umana
        if (humanPlayer.getHand() != null) {
            view.updateHand(humanPlayer.getHand().getCards());
        } else {
            view.updateHand(Collections.emptyList());
        }

        // aggiorna tavolo: passa le giocate correnti e la lista di giocatori (per mappare player->indice)
        Trick trick = game.getCurrentTrick();
        List<Play> plays = trick.getPlays();
        view.updateTable(plays, game.getPlayers());

        // aggiorna punteggi
        view.updateScores(game.getTeams());

        // indica il giocatore corrente tramite indice
        view.setCurrentPlayer(game.getCurrentPlayerIndex());
    }

    private synchronized void handleHumanPlay(org.model.Card card) {
        // verifica che sia il turno del giocatore umano
		Play play = new Play(humanPlayer,card);

		if(!game.playCard(play)){
			view.appendLog("Giocata non valida");
		}
    }

    /**
     * Se il giocatore corrente è un'IA, avvia la loro mossa in background.
     */
    private void triggerNextAiIfNeeded() {
        if (game.isRoundOver() || game.isGameOver()) return;

        Player current = game.getPlayers().get(game.getCurrentPlayerIndex());
        if (current instanceof ArtificialPlayer) {
            new SwingWorker<org.model.Card, Void>() {
                @Override
                protected org.model.Card doInBackground() throws Exception {
                    Thread.sleep(150); // breve pausa per UX
                    return ((ArtificialPlayer) current).chooseCardToPlay(game.getCurrentTrick());
                }

                @Override
                protected void done() {
                    try {
						Card card = get();
						if(card!=null){
							Play play = new Play(current, card);
							if (!game.playCard(play)) {
								view.appendLog("IA ha tentato una giocata non valida!");
							}
						}
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }.execute();
        }
    }

    private void handleGameOver() {
        SwingUtilities.invokeLater(() -> {
            JOptionPane.showMessageDialog(null, "Partita terminata!");
            navigator.navigate(Navigator.Screen.MENU);
        });
    }
}
package org.controller;


public class JTressette {
	

    public static void main(String[] args) {
        javax.swing.SwingUtilities.invokeLater(MainController::new);
    }
}
package org.controller;


import org.model.*;
import org.view.*;

import javax.swing.*;

import java.io.File;
import java.io.IOException;

/**
 * controller principale coordina il menu,il gioco e le opzioni
 */

public class MainController {

	private final UserProfile profile;
	private final File saveFile = new File("profile.properties");
	private final Navigator navigator;

	public MainController(){

		//carico o creo il profilo
		profile = loadProfile();

		//creo la finestra principale
		JFrame frame = new JFrame("JTressette");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(600,400);
		frame.setLocationRelativeTo(null);

		navigator = new Navigator(frame);

		//inizializzo le schermate

		initScreens();

		//mostro il menu iniziale
		navigator.navigate(Navigator.Screen.MENU);

		frame.setVisible(true);
	}

	private void initScreens() {
		MainMenuPanel menuPanel = new MainMenuPanel(profile);
		navigator.addScreen(Navigator.Screen.MENU,menuPanel);

		//listener per "menu delle opzioni"
		menuPanel.getOptionsButton().addActionListener( e -> {
			OptionsDialog dialog = new OptionsDialog(profile);
			dialog.setVisible(true);
			saveProfile();
		});
		menuPanel.getStartButton().addActionListener(e -> {
			String mode = menuPanel.getSelectedMode();
			startGame(mode);
		});	
		
	}

	

	private void startGame(String mode){
		System.out.println("avvio partita in modalità " + mode);

		GameModeStrategy strategy = mode.equals("2 Giocatori") ?
			new TwoPlayerStrategy() : new FourPlayerStrategy();

		TressetteGame game = new TressetteGame(strategy,profile);
		game.startGame(); // mescola e distribuisce

		// trova il player umano (primo HumanPlayer in lista)
		Player human = game.getPlayers().stream()
			.filter(p -> p instanceof org.model.HumanPlayer)
			.findFirst()
			.orElse(game.getPlayers().get(0)); // fallback

		GamePanel gamePanel = new GamePanel();
		navigator.addScreen(Navigator.Screen.GAME, gamePanel);

		// crea TablePanel e impostalo nella view PRIMA di creare il controller
		TablePanel tp = new TablePanel(game.getPlayers());
		gamePanel.setTablePanel(tp);		
		// crea controller che collegherà modello e view
		new GameController(game, gamePanel, navigator, human);

		navigator.navigate(Navigator.Screen.GAME);
	}
	private UserProfile loadProfile(){
		try {
			return UserProfile.loadFromProperties(saveFile);
		} catch (IOException e){
			return new UserProfile("Player");
		}
	}

	private void saveProfile() {
		try {
			profile.saveToProperties(saveFile);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
package org.controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class Navigator{

	/**
	 *enum che rappresenta le possibili schermate 
	 */

	public enum Screen{MENU,GAME};

	private final JFrame frame;
	private final Map<Screen,JPanel> screens = new HashMap<>();

	public Navigator(JFrame frame) {
		this.frame = frame;
		this.frame.getContentPane().setLayout(new CardLayout());
	}

	public void addScreen(Screen id, JPanel panel){

		screens.put(id,panel);
		frame.getContentPane().add(panel,id.name());
	}
	public void navigate(Screen id){
		CardLayout cl = (CardLayout) frame.getContentPane().getLayout();
		cl.show(frame.getContentPane(), id.name());
	}
}
